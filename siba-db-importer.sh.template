#!/bin/bash
#
#1. Parametros recibidos por la linea de comandos, definidos como opciones
#
#    -d ->  DB Name
#    -c ->  (Containerized) It indicates whether mysql/mariadb is runing inside a container technology or not.
#    -f ->  How many files clean_db-$3.sql must the script iterates. (optional)
#    -i ->  Input file name, without extension file name (optional)
#    -s ->  Source, The source where the file comes from, if not defined, it takes WEB_SOURCE from .env
#           It supports:
#           - http resources (web resource)
#           - local resource (same directory as PATH_TO_FILES in .env)
#           - File system resource (path to another local directory)


[-- REPLACE POR FULL TOOL PATH --]echo '>>>>> BEGIN'

DB_USER=
DB_PWD=
PATH_TO_FILES=
PATH_TO_WEB_FOLDER=
WEB_SOURCE=


: << 'COMMENT'
Definir las opciones y sus valores por defecto
COMMENT
# Definir las opciones y sus valores por defecto
dbName=""
qtyCleanFiles=0
containerized="0"
inputFileName=""
sourceFile=""

# Analizar las opciones de línea de comandos
while getopts ":d:c:f:i:s:" opt; do
  case $opt in
    d) dbName=$OPTARG;;
    c) containerized=$OPTARG;;
    f) qtyCleanFiles=$OPTARG;;
    i) inputFileName=$OPTARG;;
    s) sourceFile=$OPTARG;;
    \?) [-- REPLACE POR FULL TOOL PATH --]echo "Opción inválida: -$OPTARG" >&2;;
    :) [-- REPLACE POR FULL TOOL PATH --]echo "La opción -$OPTARG requiere un argumento." >&2;;
  esac
done



[-- REPLACE POR FULL TOOL PATH --]echo "Containerized: $containerized"

if [[ -z $dbName ]]
then
    [-- REPLACE POR FULL TOOL PATH --]echo "No se ha definido el nombre de la base de datos, este valor es obligatorio"
    exit
fi


if [[ -z $inputFileName ]]
then
    inputFileName="$dbName"
fi





if [[ "$sourceFile" == "local" ]]
then
    [-- REPLACE POR FULL TOOL PATH --]echo "Tomando fuente la carpeta: $PATH_TO_FILES"
    [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql"
else
    if [[ "$sourceFile" == "" ]]
    then
        #default behavior
        [-- REPLACE POR FULL TOOL PATH --]echo "Recuperando el archivo SQL de la fuente $WEB_SOURCE/$inputFileName.sql.tar.gz"
        [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql.tar.gz"
        [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql"
        [-- REPLACE POR FULL TOOL PATH --]wget -O "$PATH_TO_FILES/$inputFileName.sql.tar.gz" "$WEB_SOURCE/$inputFileName.sql.tar.gz"
    else
        httpRegexp="^http"
        if [[ $sourceFile =~ $httpRegexp ]]
        then
            [-- REPLACE POR FULL TOOL PATH --]echo "Recuperando el archivo SQL de la fuente $sourceFile/$inputFileName.sql.tar.gz"
            [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql.tar.gz"
            [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql"
            [-- REPLACE POR FULL TOOL PATH --]wget -O "$PATH_TO_FILES/$inputFileName.sql.tar.gz" "$sourceFile/$inputFileName.sql.tar.gz"    
        else
            if [[ "$PATH_TO_FILES" != "$sourceFile" ]]
            then
                [-- REPLACE POR FULL TOOL PATH --]echo "Recuperando el archivo SQL de la fuente $sourceFile/$inputFileName.sql.tar.gz"
                [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql.tar.gz"
                [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql"
                [-- REPLACE POR FULL TOOL PATH --]cp "$sourceFile/$inputFileName.sql.tar.gz" "$PATH_TO_FILES/$inputFileName.sql.tar.gz"
            else
                [-- REPLACE POR FULL TOOL PATH --]echo "Tomando como fuente la carpeta: $sourceFile"
                [-- REPLACE POR FULL TOOL PATH --]rm -f "$PATH_TO_FILES/$inputFileName.sql"
            fi    
        fi 
    fi
fi

[-- REPLACE POR FULL TOOL PATH --]cd $PATH_TO_FILES
[-- REPLACE POR FULL TOOL PATH --]pwd
[-- REPLACE POR FULL TOOL PATH --]tar --directory "$PATH_TO_FILES/" -xvf "$PATH_TO_FILES/$inputFileName.sql.tar.gz"
[-- REPLACE POR FULL TOOL PATH --]echo "$?"
#docker exec -i std-totalplay /usr/bin/php /var/www/app/artisan down
for ((i=1;i<=$qtyCleanFiles;i++ )); do
        [-- REPLACE POR FULL TOOL PATH --]echo "Printing forloop at $i"
        if [[ "$containerized" != '0' ]]
        then
            [-- REPLACE POR FULL TOOL PATH --]echo "Limpiando datos previos de la DB contenerizada"
            [-- REPLACE POR FULL TOOL PATH --]docker exec -i "$containerized" sh -c "exec mysql -u $DB_USER -p\"$DB_PWD\" $dbName" < "$PATH_TO_FILES/cleandbscripts/$dbName/clean_db-$i.sql"
        else
            [-- REPLACE POR FULL TOOL PATH --]echo "Limpiando datos previos de la DB que corre directamente en el servidor"
            [-- REPLACE POR FULL TOOL PATH --]mysql -u "$DB_USER" --password="$DB_PWD" "$dbName" < "$PATH_TO_FILES/cleandbscripts/$dbName/clean_db-$i.sql"
        fi
        [-- REPLACE POR FULL TOOL PATH --]echo "$?"
done



[-- REPLACE POR FULL TOOL PATH --]chmod -Rf 777 "$PATH_TO_FILES/$inputFileName.sql"
#docker exec -i "$containerDbName" sh -c "exec mysql -u $DB_USER -p\"$DB_PWD\" $dbName" < "$PATH_TO_FILES/home/siba/exports/$dbName.sql"

if [[ "$containerized" != '0' ]]
then
    [-- REPLACE POR FULL TOOL PATH --]echo "Limpiando datos previos de la DB contenerizada"
    [-- REPLACE POR FULL TOOL PATH --]docker exec -i "$containerized" sh -c "exec mysql -u $DB_USER -p\"$DB_PWD\" $dbName" < "$PATH_TO_FILES/$inputFileName.sql"
else
    [-- REPLACE POR FULL TOOL PATH --]echo "Limpiando datos previos de la DB que corre directamente en el servidor"
    [-- REPLACE POR FULL TOOL PATH --]mysql -u "$DB_USER" --password="$DB_PWD" "$dbName" < "$PATH_TO_FILES/$inputFileName.sql"
fi

[-- REPLACE POR FULL TOOL PATH --]echo '<<<<< END'
[-- REPLACE POR FULL TOOL PATH --]echo ' '                                                                                                                                                                                                
~                                                                                                                                       
